<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width", initial-scale="1.0"/>
		<meta http-equiv="X-UA-Compatible" content="ie=edge"/>
		<title>fimawork_title</title>
		<link rel="stylesheet" type="text/css" href="./Main.css">
		<style type="text/css">
			@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,500,700');  
			@import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap');
			@import url("https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" );
			
			body
			{
				margin: 0;
				padding:0; 
				background: linear-gradient(0deg,rgba(180, 180, 180, 1) 0%, rgba(89, 89, 89, 1) 30%, rgba(69, 69, 69, 1) 100%);
				overflow: hidden;
			}
			
			canvas
			{
				width: 100%;
   				height: 100%;
			}

			.background
			{
				width: 100%;
   				height: 100%;
				
			}

		</style>

		<script id="fragmentShader" type="x-shader/x-fragment">

			uniform float time;
	
			uniform float fogDensity;
			uniform vec3 fogColor;
	
			uniform sampler2D texture1;
			uniform sampler2D texture2;
	
			varying vec2 vUv;
	
			void main( void ) {
	
				vec2 position = - 1.0 + 2.0 * vUv;
	
				vec4 noise = texture2D( texture1, vUv );
				vec2 T1 = vUv + vec2( 1.5, - 1.5 ) * time * 0.02;
				vec2 T2 = vUv + vec2( - 0.5, 2.0 ) * time * 0.01;
	
				T1.x += noise.x * 2.0;
				T1.y += noise.y * 2.0;
				T2.x -= noise.y * 0.2;
				T2.y += noise.z * 0.2;
	
				float p = texture2D( texture1, T1 * 2.0 ).a;
	
				vec4 color = texture2D( texture2, T2 * 2.0 );
				vec4 temp = color * ( vec4( p, p, p, p ) * 2.0 ) + ( color * color - 0.1 );
	
				if( temp.r > 1.0 ) { temp.bg += clamp( temp.r - 2.0, 0.0, 100.0 ); }
				if( temp.g > 1.0 ) { temp.rb += temp.g - 1.0; }
				if( temp.b > 1.0 ) { temp.rg += temp.b - 1.0; }
	
				gl_FragColor = temp;
	
				float depth = gl_FragCoord.z / gl_FragCoord.w;
				const float LOG2 = 1.442695;
				float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );
				fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );
	
				gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
	
			}
	
		</script>
	
		<script id="vertexShader" type="x-shader/x-vertex">
	
			uniform vec2 uvScale;
			varying vec2 vUv;
	
			void main()
			{
	
				vUv = uvScale * uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
	
			}
	
		</script>

		<script type="importmap">
			{
			  "imports": {
				"three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
				"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
			  }
			}
		</script>

	</head>
	
	<body>  
		
		<script type="module">
		import * as THREE from 'three';

		import Stats from 'three/addons/libs/stats.module.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
		import { dracoLoader,InstGLTFDracoBase64Loader,WebGLInspector } from 'https://cdn.jsdelivr.net/gh/Fimawork/threejs_tools@V1.1/fx_functions.js';
		import { draco_logo } from './models/draco_logo_slices.js';
	
let camera, scene, renderer;
const frustumSize = 10;

const textureLoader = new THREE.TextureLoader();

const cloudTexture = textureLoader.load( 'images/Fiber 1.png' );
const lavaTexture = textureLoader.load( 'images/cloud.png' );

lavaTexture.colorSpace = THREE.SRGBColorSpace;

cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;
lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;

let uniforms = {


'time': { value: 1.0 },
'uvScale': { value: new THREE.Vector2( 1.2,1.2 ) },
'texture1': { value: cloudTexture },
'texture2': { value: lavaTexture }


};


let FogEffect_shader = new THREE.ShaderMaterial( {
side: THREE.DoubleSide,
transparent: true,
opacity:0.3,
blending: THREE.AdditiveBlending,
uniforms: uniforms,
vertexShader: document.getElementById( 'vertexShader' ).textContent,
fragmentShader: document.getElementById( 'fragmentShader' ).textContent

} );

let deltaTime=0;

const clock = new THREE.Clock();

let mixer;

init();
animate();


function init() {


	const container = document.createElement( 'div' );
	document.body.appendChild( container );

	//camera = new THREE.PerspectiveCamera( 120, window.innerWidth / window.innerHeight, 1, 2000 );
	const aspect = window.innerWidth / window.innerHeight;
  	

	camera = new THREE.OrthographicCamera(
    frustumSize * aspect / -2, // left
    frustumSize * aspect / 2,  // right
    frustumSize / 2,           // top
    frustumSize / -2,          // bottom
    0.1,                       // near
    100                       // far
  	);

	let model_angel=window.innerWidth<=450?-0.5*Math.PI:Math.PI;
	let model_scale=window.innerWidth<=450?0.4:0.8;

  	camera.position.set(0, 0, 5);
  	camera.lookAt(0,0,0);

	scene = new THREE.Scene();
	

	renderer = new THREE.WebGLRenderer( );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor(0x000000, 0);//需加入這一條，否則看不到CSS的底圖
	document.body.appendChild(renderer.domElement);

	//draco模組
  	dracoLoader.setDecoderPath( 'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/libs/draco/' );
  	dracoLoader.preload();

	//加密模組
	function base64ToArrayBuffer(base64) 
	{
		// 去除所有非 base64 字元
		base64 = base64.replace(/[^A-Za-z0-9+/=]/g, "");

    	const binary = atob(base64);
    	const len = binary.length;
    	const bytes = new Uint8Array(len);

    	for (let i = 0; i < len; i++) 
		{
    	    bytes[i] = binary.charCodeAt(i);
    	}

    	return bytes.buffer;
	}

	const arrayBuffer = base64ToArrayBuffer(draco_logo());

	const loader_title = new GLTFLoader();
	loader_title.setDRACOLoader(dracoLoader);

	loader_title.parse(
        arrayBuffer,
        '',
        (gltf) => {
            
            const model = gltf.scene;
			model.position.set(0,0,0);
			model.rotation.set(Math.PI,Math.PI, model_angel);
			model.scale.set(model_scale,model_scale,model_scale);

            model.traverse( function ( object ) {

			if ( object.isMesh )
			{
				object.material=FogEffect_shader;
			}

		});

		scene.add( model );

        },
        (error) => {
            console.error('Failed to load model:', error);
        }
    );

	container.appendChild( renderer.domElement );

	window.addEventListener( 'resize', onWindowResize );

	//WebGLInspector(container,renderer);
}

function onWindowResize() 
{
	const aspect = window.innerWidth / window.innerHeight;
    camera.left = -frustumSize * aspect / 2;
    camera.right = frustumSize * aspect / 2;
    camera.top = frustumSize / 2;
    camera.bottom = -frustumSize / 2;
    camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );
}


//類似Unity的Update()功能
function animate() {

	requestAnimationFrame( animate );

	const delta = clock.getDelta();

	if ( mixer ) mixer.update( delta );

	renderer.render( scene, camera );

	//console.log(renderer.info.render.calls);

	//stats.update();

	deltaTime=delta*0.3;

	uniforms[ 'time' ].value -=  delta*3;

}

		</script>
    </body>

</html>